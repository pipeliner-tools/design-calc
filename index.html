<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pipeline Design Calculator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <!-- jsPDF Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- html2canvas Library (for charts in PDF) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    :root {
      --bg-color: #f4f7f9;
      --card-color: #ffffff;
      --text-color: #2c3e50;
      --text-muted-color: #5a6a7a;
      --border-color: #dfe6ec;
      --input-bg-color: #ffffff;
      --input-focus-border: #3498db;
      --primary-color: #3498db; /* Blue - Calculate */
      --primary-hover-color: #2980b9;
      --btn-reset-bg: #f39c12; /* Orange - Reset */
      --btn-reset-hover-bg: #e67e22;
      --btn-export-bg: #2ecc71; /* Green - Export */
      --btn-export-hover-bg: #27ae60;
      --success-color: #2ecc71;
      --success-bg-color: #e8f9f1;
      --error-color: #e74c3c;
      --error-bg-color: #fdedec;
      --shadow-color: rgba(44, 62, 80, 0.15);
      --chart-grid-color: #e1e8ed;
      --chart-label-color: #5a6a7a;
      --chart-tooltip-bg: rgba(44, 62, 80, 0.9);
      --chart-tooltip-text: #ffffff;
      --toggle-icon: '‚òÄÔ∏è';
      --toggle-bg: #e0e0e0;
      /* --collapsible-bg: #f9fafb; -- No longer needed */
    }

    [data-theme="dark"] {
      --bg-color: #1a1d24;
      --card-color: #252a33;
      --text-color: #e1e8f0;
      --text-muted-color: #8a99a8;
      --border-color: #3a414f;
      --input-bg-color: #2f3542;
      --input-focus-border: #5fa8e4;
      --primary-color: #5fa8e4; /* Lighter Blue */
      --primary-hover-color: #7fbbe8;
      --btn-reset-bg: #f1c40f; /* Yellow-Orange */
      --btn-reset-hover-bg: #f39c12;
      --btn-export-bg: #27ae60; /* Darker Green */
      --btn-export-hover-bg: #2ecc71;
      --success-color: #3ae374;
      --success-bg-color: #1f3a2b;
      --error-color: #f56c5e;
      --error-bg-color: #4a2525;
      --shadow-color: rgba(0, 0, 0, 0.3);
      --chart-grid-color: #3a414f;
      --chart-label-color: #8a99a8;
      --chart-tooltip-bg: rgba(225, 232, 240, 0.9);
      --chart-tooltip-text: #252a33;
      --toggle-icon: 'üåô';
      --toggle-bg: #4a5162;
      /* --collapsible-bg: #2f3542; -- No longer needed */
    }

    *, *::before, *::after {
      box-sizing: border-box;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, fill 0.3s ease;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      min-height: 100vh;
    }

    .container {
      position: relative;
      background: var(--card-color);
      padding: 30px 35px;
      border-radius: 16px;
      box-shadow: 0 8px 25px var(--shadow-color);
      width: 100%;
      max-width: 700px;
      animation: slideInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      margin-bottom: 30px;
    }

    @keyframes slideInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1 {
      text-align: center;
      margin-bottom: 25px;
      padding-right: 50px;
      color: var(--primary-color);
      font-weight: 600;
    }

    label {
      font-weight: 500;
      font-size: 0.95em;
      margin-top: 15px;
      margin-bottom: 5px;
      display: block;
      color: var(--text-muted-color);
      cursor: help;
    }
    label[for="D"], label[for="t"], label[for="P"], label[for="S"] {
        cursor: default;
    }

    input[type="number"], select {
      width: 100%;
      padding: 12px 15px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background-color: var(--input-bg-color);
      color: var(--text-color);
      margin-top: 4px;
      margin-bottom: 10px;
      font-size: 1em;
      appearance: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input[type="number"]:focus, select:focus {
        outline: none;
        border-color: var(--input-focus-border);
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
    }
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
    input[type=number] { -moz-appearance: textfield; }

    select {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23888'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.22a.75.75 0 0 1 1.06 0L8 8.94l2.72-2.72a.75.75 0 1 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0L4.22 7.28a.75.75 0 0 1 0-1.06z' clip-rule='evenodd' /%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 15px center;
        background-size: 16px 16px;
        padding-right: 40px;
    }
    [data-theme="dark"] select {
         background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23bbb'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.22a.75.75 0 0 1 1.06 0L8 8.94l2.72-2.72a.75.75 0 1 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0L4.22 7.28a.75.75 0 0 1 0-1.06z' clip-rule='evenodd' /%3E%3C/svg%3E");
    }

    button {
      padding: 12px 18px;
      border: none;
      border-radius: 8px;
      font-size: 0.95em;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      outline: none;
      color: white;
    }
    button:active { transform: translateY(1px); }

    .btn-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
      margin-top: 25px;
    }

    .btn-calculate { background-color: var(--primary-color); }
    .btn-calculate:hover { background-color: var(--primary-hover-color); }
    .btn-reset { background-color: var(--btn-reset-bg); }
    .btn-reset:hover { background-color: var(--btn-reset-hover-bg); }
    [data-theme="dark"] .btn-reset { color: #333; }
    [data-theme="dark"] .btn-reset:hover { color: #222; }
    .btn-export { background-color: var(--btn-export-bg); }
    .btn-export:hover { background-color: var(--btn-export-hover-bg); }

    .output {
      margin-top: 25px;
      padding: 15px 20px;
      border-radius: 8px;
      border-left: 5px solid var(--success-color);
      background-color: var(--success-bg-color);
      font-size: 1.05em;
      animation: fadeIn 0.5s ease;
      color: var(--text-color);
    }
     [data-theme="dark"] .output { color: var(--text-color); }
     .output strong { color: var(--success-color); font-weight: 600; }

    .error {
      margin-top: 25px;
      padding: 15px 20px;
      border-radius: 8px;
      border-left: 5px solid var(--error-color);
      background-color: var(--error-bg-color);
      color: var(--error-color);
      font-weight: 500;
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    .dark-toggle {
      position: absolute; top: 25px; right: 25px;
      background: var(--toggle-bg); border: none; cursor: pointer;
      font-size: 1.3rem; border-radius: 50%;
      width: 40px; height: 40px; display: flex;
      align-items: center; justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: transform 0.3s ease, background-color 0.3s ease;
      z-index: 10; color: var(--text-color);
    }
    .dark-toggle::before {
        content: var(--toggle-icon);
        transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    }
     html[data-theme="dark"] .dark-toggle::before { transform: rotate(360deg); }
     html[data-theme="light"] .dark-toggle::before { transform: rotate(0deg); }

    canvas { margin-top: 25px; border-radius: 8px; }

    /* Removed Collapsible Section Styles */

    .form-section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      /* border-bottom: 1px solid var(--border-color); -- Removed border for cleaner look without collapsible */
    }
    /* .form-section:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    } */

    .chart-container {
      position: relative; margin: 20px 0;
      height: 300px; width: 100%;
    }
    /* Added explicit style for line chart container to ensure it's displayed */
    #lineChartContainer {
        margin-top: 30px; /* Space between charts */
    }

    @media (max-width: 600px) {
        .chart-container { height: 250px; }
         .container { padding: 20px 25px; }
         h1 { padding-right: 45px; font-size: 1.5em; }
         .dark-toggle { top: 18px; right: 15px; width: 35px; height: 35px; font-size: 1.1rem; }
    }
    footer { background-color: var(--footer-bg); color: var(--footer-text); text-align: center; padding: 20px 40px; font-size: 0.9rem; border-top: 1px solid var(--border-color); transition: background-color var(--transition-speed) var(--transition-timing), color var(--transition-speed) var(--transition-timing), border-color var(--transition-speed) var(--transition-timing); }
  </style>
</head>
<body>
  <div class="container">
    <h1>Pipeline Design Calculator</h1>
    <button class="dark-toggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode"></button>

    <form id="calcForm" onsubmit="event.preventDefault(); calculate();">
      <div class="form-section">
        <p style="text-align: center; color: var(--text-muted-color); font-size: 0.9em; margin-top: -10px; margin-bottom: 20px;">
          Calculate required Thickness for a given Design Pressure or vice versa. <br/> Enter only one of the two.
        </p>

        <label for="D">Outside Diameter (D, inches)</label>
        <input type="number" id="D" step="any" min="0" required />

        <label for="t">Wall Thickness (t, mm)</label>
        <input type="number" id="t" step="any" min="0" oninput="clearInput('P')" />

        <label for="P">Internal Design Pressure (P, kg/cm¬≤)</label>
        <input type="number" id="P" step="any" min="0" oninput="clearInput('t')" />

        <label for="S">SMYS (S, ksi)</label>
        <input type="number" id="S" step="any" min="0" value="60" required />

        <label for="F" title="Design factor based on Location Class (1-4) and facility type (e.g., Pipelines, Crossings, Stations per ASME B31.8 Table 841.1.6-2). Lower class number = higher factor = less conservative.">Location Class Design Factor (F)</label>
        <select id="F">
          <option value="0.72">Class 1 (F=0.72)</option>
          <option value="0.6">Class 2 (F=0.60)</option>
          <option value="0.5">Class 3 (F=0.50)</option>
          <option value="0.4">Class 4 (F=0.40)</option>
        </select>

        <label for="E" title="Longitudinal joint quality factor based on pipe manufacturing method (per ASME B31.8 Table 841.1.7-1). 1.0 for Seamless, ERW, SAW. 0.8 for Electric-Fusion Welded (some classes). 0.6 for Furnace-Butt Welded.">Longitudinal Joint Factor (E)</label>
        <select id="E">
          <option value="1.0">1.0 (Seamless / ERW / SAW)</option>
          <option value="0.8">0.8 (Electric-Fusion Welded)</option>
          <option value="0.6">0.6 (Furnace-Butt Welded)</option>
        </select>

        <label for="T" title="Temperature derating factor (per ASME B31.8 Table 841.1.8-1). 1.0 for ‚â§ 250¬∞F (121¬∞C). Decreases for higher temps: 0.967 @ 300¬∞F (149¬∞C), 0.933 @ 350¬∞F (177¬∞C), 0.900 @ 400¬∞F (204¬∞C), 0.867 @ 450¬∞F (232¬∞C). Interpolate for intermediate temperatures.">Temperature Derating Factor (T)</label>
        <input type="number" step="0.01" id="T" min="0" max="1" value="1.0" required />

        <div class="btn-group">
          <button type="submit" class="btn-calculate">Calculate</button>
          <button type="button" onclick="resetForm()" class="btn-reset">Reset</button>
          <button type="button" onclick="exportToPDF()" class="btn-export">Export PDF</button>
        </div>

        <div id="result" class="output" style="display: none;"></div>
        <div id="error-message" class="error" style="display: none;"></div>
      </div>

      <!-- Charts are now directly in the flow -->
      <div class="chart-container" id="barChartContainer" style="display: none;">
         <canvas id="barChart"></canvas>
      </div>
      <div class="chart-container" id="lineChartContainer" style="display: none;">
         <canvas id="pressureThicknessChart"></canvas>
      </div>
      <div id="lineChartError" class="error" style="display: none; margin-top: 15px;"></div> <!-- Error for line chart if D/S invalid -->
    </form>
          <footer class="text-center text-sm text-gray-600 dark:text-gray-400 mt-8 mb-4">
                  <p>Made by <strong>Ramakrishna Mullapudi</strong> ü§ù <strong>Gemini</strong></p>
                  <p>Copyright ¬©Ô∏è 2025</p>
          </footer>
  </div>

  <script>
    const { jsPDF } = window.jspdf; // Destructure jsPDF

    let barChart = null;
    let lineChart = null;

    const KGCM2_TO_PSI = 14.223;
    const KSI_TO_PSI = 1000;
    const MM_TO_IN = 1 / 25.4;
    const DESIGN_FACTORS = [0.72, 0.6, 0.5, 0.4];

    function mapFtoClass(fValue) {
        const fStr = Number(fValue).toFixed(2);
        switch (fStr) {
            case '0.72': return 'Class 1';
            case '0.60': return 'Class 2';
            case '0.50': return 'Class 3';
            case '0.40': return 'Class 4';
            default: return `F=${fValue}`;
        }
    }

    function toggleDarkMode() {
      const html = document.documentElement;
      const newTheme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      updateChartThemes();
    }

    function updateChartThemes() {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();
        const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-label-color').trim();
        const tooltipBg = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-bg').trim();
        const tooltipColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-text').trim();
        const datalabelColor = isDark ? '#eee' : '#333';

        const commonChartOptionsUpdate = {
             scales: {
                x: { grid: { color: gridColor }, ticks: { color: labelColor }, title: { color: labelColor } },
                y: { grid: { color: gridColor }, ticks: { color: labelColor }, title: { color: labelColor } }
            },
            plugins: {
                tooltip: { backgroundColor: tooltipBg, titleColor: tooltipColor, bodyColor: tooltipColor },
                title: { color: labelColor },
                legend: { labels: { color: labelColor } }
            }
        };

        if (barChart) {
            barChart.options = Chart.helpers.merge(barChart.options, commonChartOptionsUpdate);
            if (barChart.options.plugins.datalabels) barChart.options.plugins.datalabels.color = datalabelColor;
            barChart.update('none');
        }
        if (lineChart) {
            lineChart.options = Chart.helpers.merge(lineChart.options, commonChartOptionsUpdate);
            lineChart.update('none');
        }
    }

    function clearInput(inputIdToClear) {
        document.getElementById(inputIdToClear).value = '';
        // Hide all result/chart elements when an input is cleared
        ['result', 'error-message', 'barChartContainer', 'lineChartContainer', 'lineChartError'].forEach(id => {
            document.getElementById(id).style.display = 'none';
        });
    }

    // Removed prefillAdvancedInputs as collapsible section is gone

    function calculate() {
      const D_val = parseFloat(document.getElementById("D").value);
      const P_in = parseFloat(document.getElementById("P").value);
      const S_val = parseFloat(document.getElementById("S").value);
      const F_selected = parseFloat(document.getElementById("F").value);
      const E_val = parseFloat(document.getElementById("E").value);
      const T_val = parseFloat(document.getElementById("T").value);
      const t_in = parseFloat(document.getElementById("t").value);

      const resultDiv = document.getElementById("result");
      const errorDiv = document.getElementById("error-message");
      const barChartContainer = document.getElementById("barChartContainer");
      const lineChartContainer = document.getElementById("lineChartContainer");
      const lineChartErrorDiv = document.getElementById("lineChartError");


      // Reset all result displays
      resultDiv.style.display = 'none'; resultDiv.innerHTML = "";
      errorDiv.style.display = 'none'; errorDiv.innerHTML = "";
      barChartContainer.style.display = 'none';
      lineChartContainer.style.display = 'none';
      lineChartErrorDiv.style.display = 'none'; lineChartErrorDiv.innerHTML = "";


      let hasError = false; let errorMsg = "";
      if (isNaN(D_val) || D_val <= 0) { errorMsg += "<li>Valid Outside Diameter (D > 0) is required for all calculations.</li>"; hasError = true; }
      if (isNaN(S_val) || S_val <= 0) { errorMsg += "<li>Valid SMYS (S > 0) is required for all calculations.</li>"; hasError = true; }
      if (isNaN(E_val) || E_val <= 0 || E_val > 1) { errorMsg += "<li>Valid Joint Factor (E) is required.</li>"; hasError = true; }
      if (isNaN(T_val) || T_val <= 0 || T_val > 1) { errorMsg += "<li>Valid Temperature Factor (T) is required.</li>"; hasError = true; }

      const P_isEntered = !isNaN(P_in) && P_in > 0;
      const t_isEntered = !isNaN(t_in) && t_in > 0;

      if ((!P_isEntered && !t_isEntered) || (P_isEntered && t_isEntered)) {
        errorMsg += "<li>Please enter <strong>either</strong> Pressure (P) <strong>or</strong> Thickness (t), not both.</li>"; hasError = true;
      } else if (P_isEntered && P_in <= 0) { errorMsg += "<li>Pressure (P) must be positive.</li>"; hasError = true;
      } else if (t_isEntered && t_in <= 0) { errorMsg += "<li>Thickness (t) must be positive.</li>"; hasError = true; }

      if (hasError) {
        errorDiv.innerHTML = `<ul>${errorMsg}</ul>`; errorDiv.style.display = 'block'; return;
      }

      const S_psi = S_val * KSI_TO_PSI;
      const barChartLabels = DESIGN_FACTORS.map(f => mapFtoClass(f));
      const barChartData = [];
      let resultText = ""; let calculatedValueType = "";

      if (P_isEntered) {
        const P_psi = P_in * KGCM2_TO_PSI;
        calculatedValueType = 'Required Wall Thickness (mm)';
        DESIGN_FACTORS.forEach(f => {
          const t_calc_in = (P_psi * D_val) / (2 * S_psi * f * E_val * T_val);
          barChartData.push(t_calc_in / MM_TO_IN);
        });
        const selectedIndex = DESIGN_FACTORS.indexOf(F_selected);
        resultText = `Required Thickness for ${mapFtoClass(F_selected)} (F=${F_selected}): <strong>${barChartData[selectedIndex].toFixed(3)} mm</strong>`;
      } else {
        const t_in_unit = t_in * MM_TO_IN;
        calculatedValueType = 'Max Design Pressure (kg/cm¬≤)';
        DESIGN_FACTORS.forEach(f => {
          const P_calc_psi = (2 * S_psi * f * E_val * T_val * t_in_unit) / D_val;
          barChartData.push(P_calc_psi / KGCM2_TO_PSI);
        });
        const selectedIndex = DESIGN_FACTORS.indexOf(F_selected);
        resultText = `Max Pressure for ${mapFtoClass(F_selected)} (F=${F_selected}): <strong>${barChartData[selectedIndex].toFixed(2)} kg/cm¬≤</strong>`;
      }
      resultDiv.innerHTML = resultText; resultDiv.style.display = 'block';
      barChartContainer.style.display = 'block';
      updateBarChart(barChartLabels, barChartData, calculatedValueType);

      // Now, also generate the line chart using the main D and S values
      // The E and T values from the main form will also be used by generatePressureThicknessChart
      if (!isNaN(D_val) && D_val > 0 && !isNaN(S_val) && S_val > 0) {
         generatePressureThicknessChart(D_val, S_val); // Pass D and S
      } else {
          lineChartErrorDiv.innerHTML = "<ul><li>Valid Diameter (D) and SMYS (S) from main section are needed for Pressure vs. Thickness chart.</li></ul>";
          lineChartErrorDiv.style.display = 'block';
          lineChartContainer.style.display = 'none'; // Hide if error
      }
    }

    function updateBarChart(labels, values, dataLabel) {
      const ctx = document.getElementById('barChart').getContext('2d');
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();
      const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-label-color').trim();
      const datalabelColor = isDark ? '#eee' : '#333';

      const data = {
        labels: labels,
        datasets: [{
          label: dataLabel, data: values,
          backgroundColor: ['rgba(52,152,219,0.7)','rgba(46,204,113,0.7)','rgba(241,196,15,0.7)','rgba(231,76,60,0.7)'],
          borderColor: ['rgb(52,152,219)','rgb(46,204,113)','rgb(241,196,15)','rgb(231,76,60)'],
          borderWidth: 1, borderRadius: 5, barThickness: 'flex', maxBarThickness: 50
        }]
      };
      const config = {
        type: 'bar', data: data, plugins: [ChartDataLabels],
        options: {
          animation: false, // Disable animation for faster PDF capture if needed
          indexAxis: 'y', responsive: true, maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: { display: true, text: dataLabel + ' vs Location Class', color: labelColor, font: { size: 14 } },
            datalabels: {
              color: datalabelColor, anchor: 'end', align: 'right',
              formatter: (v) => (v > 0.001 ? v.toFixed(2) : ''), font: { weight: 'bold' }
            }
          },
          scales: {
            x: { beginAtZero: true, title: { display: true, text: dataLabel, color: labelColor }, grid: { color: gridColor }, ticks: { color: labelColor } },
            y: { title: { display: true, text: 'Location Class', color: labelColor }, grid: { display: false }, ticks: { color: labelColor } }
          }
        }
      };
      if (barChart) barChart.destroy();
      barChart = new Chart(ctx, config);
    }

    // Modified to accept D_analysis and S_analysis as parameters
    function generatePressureThicknessChart(D_analysis, S_analysis) {
        const E_main = parseFloat(document.getElementById("E").value);
        const T_main = parseFloat(document.getElementById("T").value);

        const lineChartContainer = document.getElementById("lineChartContainer");
        const lineChartErrorDiv = document.getElementById("lineChartError"); // Re-get in case it was cleared
        lineChartContainer.style.display = 'none'; // Hide initially
        lineChartErrorDiv.style.display = 'none'; lineChartErrorDiv.innerHTML = "";


        // Validation for E and T is already done in calculate(), D and S are passed
        // We assume E_main and T_main are valid if this function is called after main calc success
        // D_analysis and S_analysis are also assumed valid from main calc

        const S_psi = S_analysis * KSI_TO_PSI;
        const maxThicknessMm = 40; const thicknessStepMm = 0.5;
        const thicknessPoints_mm = [];
        for (let t = 0.5; t <= maxThicknessMm; t += thicknessStepMm) thicknessPoints_mm.push(t);

        const datasets = [];
        const lineColors = ['#3498db', '#2ecc71', '#f1c40f', '#e74c3c'];
        const maxPressureKgCm2 = 150;

        DESIGN_FACTORS.forEach((f, index) => {
            const pressureData = []; let reachedMaxPressure = false;
            thicknessPoints_mm.forEach(t_mm => {
                if (reachedMaxPressure) return;
                const t_in = t_mm * MM_TO_IN;
                let P_calc_psi = (2 * S_psi * f * E_main * T_main * t_in) / D_analysis;
                let P_calc_kgcm2 = P_calc_psi / KGCM2_TO_PSI;
                if (P_calc_kgcm2 >= maxPressureKgCm2) {
                    P_calc_kgcm2 = maxPressureKgCm2;
                    pressureData.push({ x: t_mm, y: P_calc_kgcm2 });
                    reachedMaxPressure = true;
                } else if (P_calc_kgcm2 >= 0) {
                    pressureData.push({ x: t_mm, y: P_calc_kgcm2 });
                }
            });
            datasets.push({
                label: mapFtoClass(f), data: pressureData, borderColor: lineColors[index % lineColors.length],
                fill: false, tension: 0.1, pointRadius: 0, pointHoverRadius: 5, borderWidth: 2.5
            });
        });

        const ctx = document.getElementById('pressureThicknessChart').getContext('2d');
        const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-label-color').trim();
        const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();
        const config = {
            type: 'line', data: { datasets: datasets },
            options: {
                animation: false, // Disable animation for faster PDF capture if needed
                responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                plugins: {
                    title: { display: true, text: `Pressure vs. Thickness (D=${D_analysis}", S=${S_analysis}ksi, E=${E_main}, T=${T_main})`, color: labelColor, font: { size: 14 } },
                    legend: { position: 'top', labels: { color: labelColor } },
                    tooltip: {
                        callbacks: {
                           title: (items) => (items.length > 0 ? `Thickness: ${items[0].parsed.x.toFixed(1)} mm` : ''),
                           label: (ctx) => `${ctx.dataset.label || ''}: ${ctx.parsed.y !== null ? ctx.parsed.y.toFixed(2) + ' kg/cm¬≤' : ''}`
                        }
                    },
                    datalabels: { display: false }
                },
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'Wall Thickness (mm)', color: labelColor }, grid: { color: gridColor }, ticks: { color: labelColor }, min: 0, max: maxThicknessMm },
                    y: { title: { display: true, text: 'Design Pressure (kg/cm¬≤)', color: labelColor }, grid: { color: gridColor }, ticks: { color: labelColor }, min: 0, max: maxPressureKgCm2 }
                }
            }
        };
        if (lineChart) lineChart.destroy();
        lineChart = new Chart(ctx, config);
        lineChartContainer.style.display = 'block'; // Show the container
    }

    function resetForm() {
      document.getElementById('calcForm').reset();
      document.getElementById('P').value = '';
      document.getElementById('t').value = '';
      document.getElementById('D').value = '';
      document.getElementById('S').value = '60';
      // No analysis inputs to reset
      document.getElementById('F').value = '0.72';
      document.getElementById('E').value = '1.0';
      document.getElementById('T').value = '1.0';

      ['result', 'error-message', 'lineChartError', 'barChartContainer', 'lineChartContainer'].forEach(id => {
          const el = document.getElementById(id);
          el.style.display = 'none';
          if (id.includes('ChartError') || id === 'result' || id === 'error-message') el.innerHTML = '';
      });

      if (barChart) { barChart.destroy(); barChart = null; }
      if (lineChart) { lineChart.destroy(); lineChart = null; }
    }

    async function exportToPDF() {
        const doc = new jsPDF({ unit: 'pt', format: 'a4' }); // Using points for better control with images
        let yPos = 40; // Initial Y position for text (in points)
        const lineSpacing = 18; // Spacing between lines (in points)
        const sectionSpacing = 25; // Spacing between sections (in points)
        const leftMargin = 40;
        const pageHeight = doc.internal.pageSize.getHeight();
        const pageWidth = doc.internal.pageSize.getWidth();
        const contentWidth = pageWidth - leftMargin * 2;
        const valueOffset = 180; // Horizontal offset for values to align them

        function checkNewPage(heightNeeded) {
            if (yPos + heightNeeded > pageHeight - 40) { // 40 for bottom margin
                doc.addPage();
                yPos = 40; // Reset yPos for new page
            }
        }

        doc.setFontSize(18);
        doc.setFont("helvetica", "bold");
        doc.text("Pipeline Design Calculation Report", pageWidth / 2, yPos, { align: 'center' });
        yPos += sectionSpacing * 1.5;

        checkNewPage(sectionSpacing * 1.5);
        doc.setFontSize(14);
        doc.setFont("helvetica", "bold");
        doc.text("Input Parameters", leftMargin, yPos);
        yPos += lineSpacing * 1.5;

        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");

        const inputs = [
            { label: "Outside Diameter (D):", value: `${document.getElementById("D").value || 'N/A'} in` },
            { label: "Wall Thickness (t):", value: `${document.getElementById("t").value || 'N/A'} mm` },
            { label: "Internal Design Pressure (P):", value: `${document.getElementById("P").value || 'N/A'} kg/cm¬≤` },
            { label: "SMYS (S):", value: `${document.getElementById("S").value || 'N/A'} ksi` },
            { label: "Location Class Design Factor (F):", value: document.getElementById("F").options[document.getElementById("F").selectedIndex].text || 'N/A' },
            { label: "Longitudinal Joint Factor (E):", value: `${document.getElementById("E").options[document.getElementById("E").selectedIndex].text || 'N/A'} (${document.getElementById("E").value})` },
            { label: "Temperature Derating Factor (T):", value: `${document.getElementById("T").value || 'N/A'}` }
        ];

        inputs.forEach(input => {
            checkNewPage(lineSpacing);
            doc.setFont("helvetica", "bold");
            doc.text(input.label, leftMargin, yPos);
            doc.setFont("helvetica", "normal");
            doc.text(input.value, leftMargin + valueOffset, yPos);
            yPos += lineSpacing;
        });

        checkNewPage(sectionSpacing);
        yPos += sectionSpacing - lineSpacing;

        doc.setFontSize(14);
        doc.setFont("helvetica", "bold");
        doc.text("Result", leftMargin, yPos);
        yPos += lineSpacing * 1.5;

        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        const resultText = document.getElementById("result").innerText;
        const errorContentHTML = document.getElementById("error-message").innerHTML;
        const errorDivVisible = document.getElementById("error-message").style.display !== 'none';
        const resultDivVisible = document.getElementById("result").style.display !== 'none';

        if (errorDivVisible && errorContentHTML) {
            checkNewPage(lineSpacing * 2); // Approx height for error title + one line
            doc.setFont("helvetica", "bold");
            doc.setTextColor(231, 76, 60);
            doc.text("Input Error(s):", leftMargin, yPos);
            yPos += lineSpacing;
            doc.setTextColor(0, 0, 0);
            doc.setFont("helvetica", "normal");
            const errorItems = errorContentHTML.replace(/<\/?ul>/gi, '').split(/<li>/gi).filter(item => item.trim() !== '');
            errorItems.forEach(item => {
                const cleanedItem = item.replace(/<\/li>/gi, '').replace(/<[^>]+>/g, '').trim();
                const wrappedItem = doc.splitTextToSize(`- ${cleanedItem}`, contentWidth - 10); // 10 for bullet indent
                checkNewPage(wrappedItem.length * (lineSpacing * 0.8));
                doc.text(wrappedItem, leftMargin + 10, yPos);
                yPos += wrappedItem.length * (lineSpacing * 0.8);
            });
        } else if (resultDivVisible && resultText) {
            doc.setFont("helvetica", "bold");
            const wrappedResult = doc.splitTextToSize(resultText, contentWidth);
            checkNewPage(wrappedResult.length * (lineSpacing * 0.8));
            doc.text(wrappedResult, leftMargin, yPos);
            yPos += wrappedResult.length * (lineSpacing * 0.8);
        } else {
            checkNewPage(lineSpacing);
            doc.text("No calculation performed or result available for the given inputs.", leftMargin, yPos);
            yPos += lineSpacing;
        }
        doc.setTextColor(0,0,0);
        yPos += sectionSpacing; // Space before charts

        // Add Charts
        doc.setFontSize(14);
        doc.setFont("helvetica", "bold");

        const barChartEl = document.getElementById('barChart');
        const lineChartEl = document.getElementById('pressureThicknessChart');

        if (barChartEl && document.getElementById('barChartContainer').style.display !== 'none') {
            checkNewPage(sectionSpacing + 200); // Approx height for chart title + chart image
            doc.text("Bar Chart: Value vs Location Class", leftMargin, yPos);
            yPos += lineSpacing * 1.5;
            try {
                const barCanvas = await html2canvas(barChartEl, { scale: 2, backgroundColor: null }); // Higher scale for better quality
                const barImgData = barCanvas.toDataURL('image/png');
                const imgPropsBar = doc.getImageProperties(barImgData);
                const imgHeightBar = (imgPropsBar.height * contentWidth) / imgPropsBar.width;
                checkNewPage(imgHeightBar + lineSpacing);
                doc.addImage(barImgData, 'PNG', leftMargin, yPos, contentWidth, imgHeightBar);
                yPos += imgHeightBar + sectionSpacing;
            } catch (e) {
                console.error("Error capturing bar chart:", e);
                checkNewPage(lineSpacing);
                doc.setFont("helvetica", "italic").setTextColor(150,150,150);
                doc.text("Bar chart could not be rendered in PDF.", leftMargin, yPos);
                yPos += lineSpacing;
                doc.setTextColor(0,0,0);
            }
        }

        if (lineChartEl && document.getElementById('lineChartContainer').style.display !== 'none') {
            checkNewPage(sectionSpacing + 200);
            doc.setFont("helvetica", "bold");
            doc.text("Line Chart: Pressure vs Thickness", leftMargin, yPos);
            yPos += lineSpacing * 1.5;
            try {
                const lineCanvas = await html2canvas(lineChartEl, { scale: 2, backgroundColor: null });
                const lineImgData = lineCanvas.toDataURL('image/png');
                const imgPropsLine = doc.getImageProperties(lineImgData);
                const imgHeightLine = (imgPropsLine.height * contentWidth) / imgPropsLine.width;
                checkNewPage(imgHeightLine + lineSpacing);
                doc.addImage(lineImgData, 'PNG', leftMargin, yPos, contentWidth, imgHeightLine);
                yPos += imgHeightLine + sectionSpacing;
            } catch (e) {
                console.error("Error capturing line chart:", e);
                checkNewPage(lineSpacing);
                doc.setFont("helvetica", "italic").setTextColor(150,150,150);
                doc.text("Line chart could not be rendered in PDF.", leftMargin, yPos);
                yPos += lineSpacing;
                 doc.setTextColor(0,0,0);
            }
        }

        // Footer on the last page
        const finalPageCount = doc.internal.getNumberOfPages();
        doc.setPage(finalPageCount); // Go to last page
        yPos = pageHeight - 30;
        doc.setFontSize(8);
        doc.setFont("helvetica", "italic");
        doc.text(`Report generated on: ${new Date().toLocaleString()}`, leftMargin, yPos);
        doc.text(`Page ${finalPageCount}`, pageWidth - leftMargin - 20, yPos);


        doc.save('Pipeline_Design_Report.pdf');
    }


    function initialize() {
        Chart.register(ChartDataLabels);
        document.documentElement.setAttribute('data-theme', 'light');
        updateChartThemes();
    }

    document.addEventListener('DOMContentLoaded', initialize);

  </script>
</body>
</html>